<!doctype html>
<html lang="ru">
<head>
    <meta charset="utf-8">
    <title>Storage APIs</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="stylesheet" href="../../@lib/core.css">
    <link rel="stylesheet" href="../../@lib/theme.css">
    <!-- <link rel="stylesheet" href="index.css"> -->
</head>
<body class="white"><div class="reveal">
    <div class="slides">

        <section class="large center">
            <h2>Web Api</h2>
            <p><span class="grey">Cookies, Storages, IndexedDB, History APi</span></p>
        </section>

        <section class="center">
            <p class="red">В данной лекции обсуждается браузерное API</p>
        </section>

        <section class="center" style="width: 600px; position: absolute; margin-left: auto; margin-right: auto; left: 0; right: 0; top: 0">
            <img src="images/map.png">
        </section>

        <section class="center" style="width: 600px; position: absolute; margin-left: auto; margin-right: auto; left: 0; right: 0; top: 0">
            <img src="images/music.png">
        </section>

        <section class="center" style="width: 600px; position: absolute; margin-left: auto; margin-right: auto; left: 0; right: 0; top: 0">
            <img src="images/cookie.jpg">
        </section>

        <section>
            <h2>Создание</h2>
            <pre class="javascript"><code data-noescape data-trim>
        <span>document.cookie = 'subject=Song'</span>

        <span>document.cookie = 'subject=Beautiful-song';</span>

        <span>document.cookie = 'volume=5';</span>

        <span>document.cookie = 'subject=' + encodeURIComponent('Песня');
        // %D0%9F%D0%B5%D1%81%D0%BD%D1%8F</span>
            </code></pre>
        </section>

        <section class="center">
            <p>uniq key = name + path + domain</p>
        </section>

        <section class="center">
            <pre class="javascript">
                <code data-noescape data-trim>
                    <span style="font-size: .8em">document.cookie = 'subject=Song; path=/users; domain=yandex.ru';</span>

                    <span style="font-size: .8em" class="green">path=/</span>

                    <span style="font-size: .8em" class="green">domain=music.yandex.ru;</span>

                    <span style="font-size: .8em" class="green">path=/users/playlists;</span>

                    <span style="font-size: .8em" class="red">path=/usersplaylists; domain=yandex.ru;</span>

                    <span style="font-size: .8em" class="red">domain=facebook.com;</span>
                </code>
            </pre>
        </section>

        <section class="center">
            <h2>expires</h2>

            <pre class="javascript">
                <code data-noescape data-trim>
                    subject=Song; <span class="red">expires=Tue, 10 Mar 2020 14:20:00 GMT</span>
                </code>
            </pre>
        </section>

        <section class="center">
            <p>Чтобы <span class="red">удалить</span>, устанавливаем дату устаревания в прошлом</p>
        </section>

        <section class="center">
            <pre class="javascript" style="text-align: center;">
                <code data-noescape>subject=Song; expires=Tue, <span class="red">10 Mar 1970</span> 00:00:00 GMT</code>
            </pre>
        </section>

        <section>
            <h2>Чтение</h2>
            <pre class="javascript">
                <code data-noescape data-trim>
                    document.cookie = 'subject=Song; path=/';

                    <span>console.log(document.cookie);</span>
                    // subject=Song
                </code>
            </pre>
        </section>

        <!-- <section>
            <h2>Чтение</h2>
            <pre class="javascript">
                <code data-noescape data-trim>
                    <span style="color: #00df50">document.cookie</span> = 'subject=Song; path=/';
                    <span style="color: #5000df">document.cookie</span> = 'subject=Song; path=/users';

                    <span>console.log(document.cookie);</span>
                </code>
            </pre>
            <p>Раньше будет выведена cookie с заданным
                <span style="color: #5000df">path=/users</span> или с
                <span style="color: #00df50">path=/</span>?
            </p>
        </section> -->

        <!-- <section class="center">
            <p>Если подходят несколько – доступны все в порядке от наиболее специфичной к наименее</p>
        </section>

        <section>
            <h2>Чтение</h2>
            <pre class="javascript">
                <code data-noescape data-trim>
                    <span style="color: #00df50">document.cookie</span> = 'subject=Song; path=/';
                    <span style="color: #5000df">document.cookie</span> = 'subject=Song; path=/users';</span>

                    <span>console.log(document.cookie);</span>

                    <span style="color: #5000df">subject=Song;</span>
                    <span style="color: #00df50">subject=Song;</span>
                </code>
            </pre>
        </section> -->

        <section>
            <h2><a href="https://github.com/js-cookie/js-cookie">js-cookie</a></h2>

            <pre class="javascript">
                <code data-noescape data-trim>
                    <span>Cookies.set('subject', 'Song', { expires: 7, path: '' });</span>

                    <span>Cookies.get('subject');</span>

                    <span>Cookies.remove('subject');</span>
                </code>
            </pre>
        </section>

        <section>
            <h2>Отправка на сервер</h2>
            <pre class="html"><code data-trim data-noescape>
            GET / HTTP/1.1
            Host: music.yandex.ru
            <span class="green">Cookie: subject=Song; playlist=1</span>
            </code></pre>

            <pre class="fragment"><code data-noescape data-trim>
        const express = require('express')
        const app = express();
        const cookieParser = require('cookie-parser');

        app.use(cookieParser());

        app.use((req, res) => {
            console.log(req.cookies);
            // { subject: 'Song', playlist: '1' }
        });
            </code></pre>
        </section>

        <section>
            <h2>Отправка на клиент</h2>

            <pre class="tail">
                <code data-noescape data-trim>
                    var express = require('express')
                    var app = express();

                    app.use((req, res) => {
                        res.cookie('subject', 'Song', { path: '/users' });
                    });

                    // Заголовок <span class="green">Set-Cookie</span> используется
                    // для отправки cookie с сервера на клиентское приложение,
                    // он дает клиенту указание сохранить cookie

                </code>
            </pre>
        </section>


        <section>
            <h2>Отправка на клиент</h2>

            <pre class="tail">
                <code data-noescape data-trim>
                    var express = require('express')
                    var app = express();

                    app.use((req, res) => {
                        res.cookie('subject', 'Song', { path: '/users' });
                    });

                    HTTP/1.1 200 OK

                    <span class="green">Set-Cookie: subject=Song; path=/users</span>
                </code>
            </pre>
        </section>


        <section>
            <h2>Отправка на клиент</h2>
            <p style="font-size: 0.8em;">
                Заголовок <span class="green">Set-Cookie</span> используется
                для отправки cookie с сервера на клиентское приложение
            </p>
            <p style="font-size: 0.8em;">Он даёт клиенту указание сохранить куки</p>
            <p style="font-size: 0.8em;">
                Теперь с каждым новым запросом к серверу, при помощи заголовка
                <span class="green">Cookie</span>, браузер будет возвращать серверу все сохранённые ранее куки
            </p>
        </section>


        <section class="center">
            <h2>Безопасность</h2>
        </section>

        <section>
            <h2>HTTP-only</h2>

            <pre class="html"><code data-noescape data-trim>
                res.cookie('subject', 'Song', {
                    path: '/users',
                    <span class="green">httpOnly: true</span>
                });
            </code></pre>

            <pre class="html"><code data-noescape data-trim>

            HTTP/1.1 200 OK
            Set-Cookie: subject=Song; path=/users; <span class="green">HttpOnly</span>
            </code></pre>
        </section>

        <section class="center">
            <p>
                Куки <span class="green">HTTP-only</span> не доступны из JavaScript через свойства Document.cookie API, что
                <span class="green">помогает избежать межсайтового скриптинга (XSS)</span
            ></p>
        </section>


        <section class="center">
            <p style="font-size: 0.8em">
                По умолчанию куки, установленные сайтом <span class="green">http://site.com</span>,
                также будут доступны на сайте <span class="green">https://site.com</span> и наоборот.
            </p>
            <p style="font-size: 0.8em">
                То есть по умолчанию <span class="red">куки</span> опираются на доменное имя,
                они <span class="red">не обращают внимания на протоколы</span>.
            </p>
        </section>

        <section>
            <h2>Secure</h2>

            <pre class="html"><code data-noescape data-trim>
                res.cookie('subject', 'Song', {
                    path: '/users',
                    <span class="green">secure: true</span>
                });
            </code></pre>

            <pre class="html"><code data-noescape data-trim>
            HTTP/1.1 200 OK
            Set-Cookie: subject=Song; path=/users; <span class="green">secure</span>
            </code></pre>
        </section>


        <section>
            <h2>Secure</h2>

            <p>
                Куки <span class="green">Secure</span> отсылаются на сервер, только если запрос выполняется по протоколу <span class="green">SSL</span> и
                <span class="green">HTTPS</span>
            </p>
            <p class="red">
                Начиная с Chrome 52 и Firefox 52, незащищенные сайты (http:) не могут создавать куки с флагом secure.
            </p>
        </section>


        <section class="center">
            <h2>Кратко</h2>
        </section>


        <section class="center">
            <h2><span class="green">Устаревание</span></h2>
        </section>

        <section class="center">
            <h2><span class="green">Доступ с сервера</span></h2>
        </section>

        <section class="center">
            <p>
                После <span style="color: grey">encodeURIComponent</span> пара
                    <span style="color: grey">name=value</span> <span class="red">не должна занимать более 4Кб</span>
            </p>
            <p>
                Общее количество куки на один домен – <span class="red">примерно 20+</span>. Точное ограничение зависит от конкретного браузера.
            </p>
        </section>

        <section class="center">
            <p><span class="red">Передаются с каждым запросом</span> в заголовке, который не сжимается</p>
        </section>

        <section class="center">
            <h2>Что делать?</h2>
        </section>

        <section class="center">
            <p>Для статики используйте<br><span class="green">cookieless</span> домены (CDN)</p>
        </section>

        <section class="center">
            <p>В cookie храните <span class="green">id</span>, по которому можно на сервере получить полные данные</p>
        </section>

        <!-- <section class="center">
            <p>Кодируйте <span class="green">01100101</span></p>
        </section> -->

        <section class="center">
            <p><a href="https://www.netsparker.com/blog/web-security/same-site-cookie-attribute-prevent-cross-site-request-forgery/">Using the Same-Site Cookie Attribute to Prevent CSRF Attacks</a></p>
            <p><a href="https://en.wikipedia.org/wiki/HTTP_cookie#SameSite_cookie">HTTP cookie</a></p>
        </section>

        <section class="center" style="position: absolute; margin-left: auto; margin-right: auto; left: 0; right: 0; width: 647px; top: 0">
            <img src="images/localstorage.jpg">
        </section>

        <section class="center">
            <h2><a href="https://html.spec.whatwg.org/multipage/webstorage.html">WebStorage</a></h2>
        </section>

        <!-- <section class="center">
            <h2>Зачем?</h2>
        </section>

        <section class="center">
            <pre class="javascript">
                <code data-noescape data-trim>
                    <label>
                    <input type="checkbox" onchange="sessionStorage.insurance = checked ? 'true' : ''">
                    I want insurance on this trip
                    </label>
                </code>
            </pre>

            <pre class="javascript">
                <code data-noescape data-trim>
                    if (sessionStorage.insurance) {...}
                </code>
            </pre>
        </section> -->

        <section class="center">
            <h2><span class="green">SessionStorage</span> хранит данные до окончания сессии (до закрытия вкладки/окна)</h2>
        </section>

        <section class="center">
            <pre class="javascript" style="height: 110px;">
                <code data-noescape data-trim>
                    <script>
                        if (sessionStorage.hits )  {
                            sessionStorage.hits =  Number(sessionStorage.hits) + 1;
                        }  else {
                            sessionStorage.hits =  1;
                        }
                        document.write(`Total Hits: ${sessionStorage.hits}`);
                    </script>
                </code>
            </pre>

            <pre class="javascript">
                <code data-noescape data-trim>
                if (sessionStorage.hits )  {
                    sessionStorage.hits =  Number(sessionStorage.hits) + 1;
                } else {
                    sessionStorage.hits =  1;
                }

                // Обновите страницу, чтобы увеличить количество просмотров;
                // Закройте окно, откройте его снова и проверьте результат
                </code>
            </pre>
        </section>

        <section class="center">
            <h2><span class="green">LocalStorage</span> хранит данные перманентно, пока скрипт или пользователь не удалит их</h2>
        </section>

        <section class="center">
            <pre class="javascript" style="height: 110px;">
                <code data-noescape data-trim>
                    <script>
                        if (localStorage.hits )  {
                            localStorage.hits =  Number(localStorage.hits) + 1;
                        }  else {
                            localStorage.hits =  1;
                        }
                        document.write(`Total Hits: ${localStorage.hits}`);
                    </script>
                </code>
            </pre>

            <pre class="javascript">
                <code data-noescape data-trim>
                if (localStorage.hits )  {
                    localStorage.hits =  Number(localStorage.hits) + 1;
                } else {
                    localStorage.hits =  1;
                }

                // Обновите страницу, чтобы увеличить количество просмотров;
                // Закройте окно, откройте его снова и проверьте результат
                </code>
            </pre>
        </section>

        <section class="center">
            <h2>Далее рассматриваем <span style="color: grey;">WebStorage</span> на примере
                <span class="green">LocalStorage</span>, для <span class="red">SessionStorage</span> – аналогично</h2>
        </section>

        <section class="center">
            <h2>
                Не передаёт данные на сервер, то есть <span class="green">устранены проблемы безопасности</span>,
                которую представляют куки
            </h2>
        </section>

        <section class="center">
            <h2>Ограничение в <span class="green">10Mb</span></h2>
        </section>

        <section class="center">
            <h2><span class="green">Хранилище привязано к источнику</span></h2>
            <p style font-size="0.8em">Разные домены определяют разные объекты хранения, они не могут получить доступ к данным друг от друга</p>
        </section>

        <section>
            <h2>Интерфейс</h2>
            <pre class="javascript">
                <code data-noescape data-trim>
                    localStorage.setItem('volume', 8);

                    localStorage.length // 1

                    localStorage.getItem('volume'); // "8"

                    localStorage.removeItem('volume')

                    localStorage.clear();

                    <span class="fragment">localStorage.setItem('repeat', 1);
                    // QUOTA_EXCEEDED_ERROR</span>
                </code>
            </pre>
        </section>

        <section class="center">
            <p>Хранит <span class="green">строки</span>, а не объекты</p>
            <pre class="javascript"><code data-noescape data-trim>
    localStorage.setItem(
        'options',
        { volume: 8 }
    );

    localStorage.getItem('options'); // "[object Object]"

    // Если нужен объект, нужно сериализовать его
    // с помощью JSON.stringify
    localStorage.setItem(
        'options',
        JSON.stringify({ volume: 8 })
    );
            </code></pre>
        </section>


        <section class='center'>
            <h2>Storage event</h2>
            <p><span class="green">Storage event сигнализирует</span>, что данные в объектах <span class="green">localStorage</span>
                или <span class="green">sessionStorage</span> были изменены</p>
        </section>


        <section>
            <h2>Storage event</h2>
            <pre class="javascript">
                <code data-noescape data-trim>
            localStorage.colorSetting = 'grey'

            // script
            window.addEventListener('storage', (event) => {
            // When local storage changes, dump this data to the console.
                console.log('localStorage', window.localStorage);
                console.log('event', event);
            });
                    <script>
                        window.addEventListener('storage', event => {
                            console.log('event', event);
                            console.log('localStorage', window.localStorage);
                        });
                    </script>
                </code>
            </pre>
        </section>

        <section>
            <h2>Storage event</h2>
            <pre class="javascript">
                <code data-noescape data-trim>
            localStorage.colorSetting = 'grey'

            window.addEventListener('storage', () => {
                console.log('localStorage', window.localStorage);
            });

            <span style="color:blue">Что в консоли?</span>
            <span class="green">
            length: 1
            colorSetting: "grey"
            </span>
                </code>
            </pre>
        </section>

        <section>
            <h2>Storage event</h2>
            <pre class="javascript">
                <code data-noescape data-trim>
            localStorage.colorSetting = 'grey'

            window.addEventListener('storage', event => {
                console.log('event', event);
            });

            <span style="color:blue">Что в консоли?</span>
            <span class="green">
            key: "colorSetting"
            oldValue: null
            newValue: "grey"
            ...
            </span>
                </code>
            </pre>
        </section>

        <!-- <section>
            <h2>Приватный режим</h2>
            <pre class="flat javacript"><code data-noescape data-trim>
        try {
            localStorage.setItem('options', '8');
        } catch (error) {
            console.error(error);
            // SecurityError: The operation is insecure
        }
            </code></pre>
        </section> -->

        <section class="center">
            <h2>Кратко</h2>
        </section>

        <section class="center">
            <h2 class="green">Хранение настроек</h2>
            <h2 class="green">Хранение промежуточных данных</h2>
        </section>

        <section class="center">
            <h2>Строго ограничено источником (origin)</h2>
        </section>

        <section class="center">
            <h2><span class="red">Синхронный</span> интерфейс</h2>
        </section>

        <section class="center">
            <p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API">Web Storage API</a></p>
            <p><a href="http://www.amazon.com/Client-Side-Data-Storage-Keeping-Local/dp/1491935111">Html5 Local Storage How-To</a></p>
            <p><a href="http://www.amazon.com/Instant-HTML5-Local-Storage-How-ebook/dp/B00C1COMDG">Client-side Data Storage</a></p>
        </section>

        <section class="center">
            <h2><a href="https://www.w3.org/TR/webdatabase/">WebSQL</a></h2>
        </section>

        <section class="center">
            <h2><span class="green">Асинхронный интерфейс</span> к SQLite базе</h2>
        </section>

        <section>
            <pre class="javascript"><code data-noescape data-trim>
        const db = openDatabase('my-app', '1.0', null, 1024 * 1024);

        db.transaction(tr => {
            tr.executeSql(`
                create table if not exists notes(
                    name TEXT
                )
            `);

            tr.executeSql(`
                insert into notes(name)
                values("films")
            `);
        }, console.error);
            </code></pre>
        </section>

        <section class="center">
            <p><img src="images/websql-ciu.png"></p>
        </section>

        <section class="center" style="width: 615px;
            position: absolute;
            margin-left: auto;
            margin-right: auto;
            left: 0;
            right: 0;">
            <img src="images/frozen.jpg">
        </section>

        <section class="center">
            <h2><a href="https://www.w3.org/TR/IndexedDB-2/">IndexedDB</a></h2>
        </section>

        <section class="center">
            <img src="images/indexeddb-ciu.png">
        </section>

        <section class="center">
            <h2>Строго ограничено источником (origin)</h2>
        </section>

        <section class="center">
            <h2>Нет ограничений на размер<span class="grey">*</span></h2>
        </section>

        <section class="center">
            <h2>Асинхронное</h2>
        </section>

        <section class="center">
            <h2>Поддерживает <span class="green">транзакции</span> для надёжности</h2>
        </section>

        <section class="center">
            <p>Основная концепция – <span class="green">хранилище объектов</span>, в других БД это «таблицы» или «коллекции»</p>
            <p style="font-size: 0.8em">При этом может быть множество хранилищ: для пользователей, для товаров и т.д.</p>
        </section>

        <!-- <section class="center">
            <p>Не SQL, а <span class="green">API</span></p>
        </section> -->

        <section class="center">
            <p>Хранилище объектов <span class="green">всегда сортирует значения по ключам внутри</span></p>
            <p style="font-size: .8em">Поэтому запросы, возвращающие много значений, всегда возвращают их в отсортированном порядке</p>
        </section>

        <section>
            <h2>Создание</h2>
            <pre class="flat"><code data-noescape data-trim>
                Указываем название (name) и версию (version) базы данных:

                const requestDb = indexedDB.open(name, version);

                Версия – положительное целое число, по умолчанию 1
            </code></pre>
        </section>


        <section class="center">
            <p>У нас может быть <span class="green">множество баз данных с различными именами</span>, но все они <span class="green">существуют в контексте текущего источника</span> (домен/протокол/порт)</p>
            <p><span class="red">Разные сайты не могут получить доступ к базам данных друг друга</span></p>
        </section>


        <section>
            <h2>Создание</h2>
            <pre class="flat"><code data-noescape data-trim>
                const requestDb = indexedDB.open('my-app', 1);
                // Метод open возвращает объект IDBOpenDBRequest
                // с тремя обработчиками: onerror, onsuccess, onupgradeneeded

                // error – не удалось открыть базу данных
                requestDb.onerror = event => {
                    console.log(event.target.errorCode);
                };
            </code></pre>
        </section>


        <section>
            <h2>Создание</h2>
            <pre class="flat"><code data-noescape data-trim>
                const requestDb = indexedDB.open('my-app', 1);
                // Метод open возвращает объект IDBOpenDBRequest
                // с тремя обработчиками: onerror, onsuccess, onupgradeneeded

                // success – база данных готова к работе,
                // готов «объект базы данных»
                requestDb.onsuccess = event => {
                    const db = event.result;
                    // продолжить работу с базой данных, используя объект db
                };
            </code></pre>
        </section>


        <section>
            <h2>Создание</h2>
            <pre class="flat"><code data-noescape data-trim>
                const requestDb = indexedDB.open('my-app', 1);
                // Метод open возвращает объект IDBOpenDBRequest
                // с тремя обработчиками: onerror, onsuccess, onupgradeneeded

                upgradeneeded – база открыта, но её схема устарела
            </code></pre>
        </section>

        <section>
            <h2>Про версионирование</h2>

            <p class="red">Такой механизм отсутствует в серверных базах данных</p>

            <p class="red">IndexedDB работает на стороне клиента, прямого доступа к данным нет</p>

            <p>Публикуем новую версию приложения – возможно нужно обновить БД</p>
        </section>


        <section>
            <h2>Про версионирование</h2>

            <p class="red">
                Локальная версия БД < версия, определённая в open
            </p>
            <p>
                Возникнет событие upgradeneeded, <span class="green">позволяющее сравнить версии и
                обновить структуры данных</span>
            </p>

            <p>Также cобытие сработает, если БД еще не существует – <span class="green">можно будет инициализировать</span></p>
        </section>


        <section class="center">
            <h2>Про версионирование</h2>
            <p class="grey" style="font-size: 40px;">Впервые публикуем приложение, версия БД = 1</p>
            <pre class="flat" style="margin-top: -75px;">
                <code data-noescape data-trim>
                let openRequest = indexedDB.open("store", 1);
                openRequest.onupgradeneeded = function() {
                    // срабатывает, если на клиенте нет базы данных
                    // ...выполнить инициализацию...
                };

                openRequest.onerror = function() {
                    console.error("Error", openRequest.error);
                };

                openRequest.onsuccess = function() {
                    let db = openRequest.result;
                    // продолжить работу с базой данных, используя объект db
                };
                </code>
            </pre>
        </section>


        <section class="center">
            <h2>Про версионирование</h2>
            <p class="green">К чему приведёт попытка открыть БД более старой версии, чем текущая?</p>
            <p>Например, на клиенте база версии 3, а мы вызываем open(...2)</p>
            <p class="red">Возникнет ошибка, сработает openRequest.onerror</p>
        </section>


        <section class="center">
            <h2>Про версионирование</h2>
            <p class="red">Проблема параллельного обновления</p>
            <p>Один пользователь. Один сайт. Одна вкладка была открыта до того как выкатили одновление, другая – после</p>
            <p class="red" style="font-size: 0.8em">БД одна на 2 вкладки, так как это один и тот же сайт</p>
            <p class="red" style="font-size: 0.8em">БД не может быть версий 1 и 2 одновременно</p>
        </section>


        <section class="center">
            <h2>Про версионирование</h2>
            <p class="red">Проблема параллельного обновления</p>
            <p>Чтобы обновить на версию 2, все соединения к версии 1 должны быть закрыты</p>
        </section>


        <section class="center">
            <h2>Про версионирование</h2>
            <p class="red">Проблема параллельного обновления</p>
            <p class="green">При попытке обновления возникает событие versionchange. Нам нужно слушать его и закрыть соединение к базе</p>
            <p class="red">Если мы его не закроем, то второе, новое соединение, будет заблокировано с событием blocked вместо success.</p>
        </section>


        <section class="center">
            <h2>Хранилище объектов</h2>
            <p class="green">Это основная концепция IndexedDB</p>
            <p class="green">Мы можем хранить почти любое значение – и сложные объекты, и примимтивы</p>
            <p>IndexedDB использует <a href="https://www.w3.org/TR/html53/infrastructure.html#section-structuredserializeforstorage">
                стандартный алгоритм сериализации</a> для клонирования и хранения объекта</p>
            <p class="red">Нельзя сохранить объект с циклическими ссылками</p>
        </section>


        <section class="center">
            <h2>Ключи</h2>
            <p>Каждому значению в хранилище должен соответствовать уникальный ключ</p>
            <p>Ключ должен быть одним из следующих типов: number, date, string, binary или array</p>
            <p class="green">IndexedDB позволяет установить свойство объекта в качестве ключа</p>
            <p class="green">Ключи можно сгенерировать автоматически</p>
        </section>


        <section class="center">
            <h2>Создание хранилища объектов</h2>

            <pre class="flat" style="margin-top: -75px;">
                <code data-noescape data-trim>
                    db.createObjectStore(name[, keyOptions]);

                    // name – название хранилища;
                    // keyOptions – это необязательный объект со свойствами:
                    //     keyPath – путь к свойству объекта, которое IndexedDB
                    //         будет использовать в качестве ключа, например id
                    //     autoIncrement – если true, то ключ будет
                    //         формироваться автоматически для новых объектов,
                    //         как постоянно увеличивающееся число.
                </code>
            </pre>
        </section>



        <section class="center">
            <h2>Создание хранилища объектов (пример)</h2>

            <pre class="flat">
                <code data-noescape data-trim>
                    db.createObjectStore(name[, keyOptions]);

                    db.createObjectStore('books', { keyPath: 'id' });
                    // Хранилище объектов books использует свойство id как ключ
                </code>
            </pre>
        </section>

        <section class="center">
            <h2>Удаление хранилища объектов (пример)</h2>

            <pre class="flat">
                <code data-noescape data-trim>
                    db.deleteObjectStore('books')
                </code>
            </pre>
        </section>


        <!-- <section class="center">
            <h2>Обновление</h2>
            <pre class="flat" style="margin-top: -75px;">
                <code data-noescape data-trim>
                    // Будет вызван в первый раз, и когда сменилась версия
                    requestDb.onupgradeneeded = event => {
                        const db = event.target.result;
                        const oldVersion = event.oldVersion;
                        // Инструкции к миграции на вторую версию
                        if (oldVersion < 2) {
                            // Создаём хранилище для заметок
                            // IndexedDB оперирует не таблицами,
                            // а хранилищами объектов: ObjectStore
                            db.createObjectStore('notes', {
                                keyPath: 'id', // Имя ключевого поля
                                autoIncrement: true
                            });
                        }
                    }
                </code>
            </pre>
        </section> -->

        <section class="center">
            <p>
                <span class="green">Можем добавлять/удалять/обновлять данные вне обработчика onupgradeneeded</span>
            </p>
            <br>
            <p>
                <span class="red">Можем создавать/удалять/измененять хранилище объектов только при обновлении версии БД внутри обработчика onupgradeneeded</span>
            </p>
        </section>

        <section class="center">
            <h2 class="green">Любые операции с данными в IndexedDB происходят в рамках транзакции</h2>
            <p style="font-size: .7em">
                Это обеспечивает целостность базы данных (в случае сбоя операции транзакция откатывается)
            </p>
        </section>


        <section class="center">
            <h2>Начинаем транзакцию</h2>
            <pre class="flat">
                <code data-noescape data-trim>
                    db.transaction(store[, type]);

                    // store – это название хранилища, может быть массивом,
                    // если нужно предоставить доступ к нескольким хранилищам.
                    // type – тип транзакции, один из:
                    //    readonly – только чтение, по умолчанию;
                    //    readwrite – только чтение и запись данных,
                    //      создание/удаление самих хранилищ объектов недоступно.
                </code>
            </pre>
        </section>


        <section class="center">
            <h2>Транзакция versionchange</h2>
            <p>Такие транзакции могут делать любые операции, <span class="red">но мы не можем создать их вручную</span></p>
            <p>IndexedDB автоматически создаёт транзакцию типа <span class="green">versionchange</span>,
                когда открывает базу данных, для обработчика <span class="green">updateneeded</span></p>
        </section>


        <section>
            <h2>Добавление объекта</h2>
            <pre class="flat" style="margin-top: -75px;">
                <code data-noescape data-trim>
                    // Открываем транзакцию
                    // Указываем, к каким Store будет иметь доступ транзакция
                    const transaction = db.transaction('notes', 'readwrite');
                    // В рамках транзакции получаем ссылку на объект Store
                    const store = transaction.objectStore('notes');
                    // Выполняем запрос в хранилище
                    // и добавляем заметку
                    const request = store.add({
                        id: 'films',
                        name: 'films'
                    });

                    request.onerror = err => console.error(err);

                    transaction.abort();
                </code>
            </pre>
        </section>

        <!-- <section class="center">
            <p>Транзакция остаётся “живой“, если есть активные запросы к концу event loop цикла</p>
        </section> -->

        <section class="center">
            <p>Может быть несколько паралелльных <span class="green">readonly</span> транзакций, но только одна <span class="green">readwrite</span></p>
            <p style="font-size: 0.6em"><span class="green">readwrite</span> транзакция “блокирует” хранилище для записи</p>
        </section>

        <section>
                <h2>Получение объекта</h2>
                <pre class="flat">
                    <code data-noescape data-trim>
                        // Открываем транзакцию
                        // Указываем, к каким Store будет иметь доступ транзакция
                        const transaction = db.transaction(['notes'], 'readonly');
                        // В рамках транзакции получаем ссылку на объект Store
                        const store = transaction.objectStore('notes')
                        // Выполняем запрос в хранилище
                        // Получаем данные, используя значения ключа (id)
                        const request = store.get('films')

                        request.onsuccess = note => console.log(note)
                    </code>
                </pre>
            </section>

        <section class="center">
            <h2 class="green">Метод get удобно использовать, если знаем ключ, по которому хотим получить данные</h2>
            <p style="font-size: .7em">А если хотим пройти через все записи в ObjectStore?</p>
        </section>

        <section class="center">
            <h2 class="green">Можно воспользоваться курсором</h2>
            <p style="font-size: .7em">Курсор – особый объект, который пересекает ObjectStore с заданным запросом
                и возвращает по одному ключу/значению за раз, таким образом экономя память
            </p>
        </section>

        <section>
            <h2>Чтобы <span class="green">получить все объекты</span>, используем курсор</h2>
            <pre>
                <code data-noescape data-trim>
                    const requestCursor = db.transaction(['notes'], 'readonly')
                        .objectStore('notes').openCursor();
                    requestCursor.onsuccess = event => {
                        const cursor = event.target.result;
                        if (cursor) {
                            console.log(cursor.key, cursor.value);
                            cursor.continue();
                        } else {
                            console.log("No more notes");
                        }
                    };
                    </code>
                </pre>
        </section>

        <section class="center">
            <p>
                Основное отличие курсора в том, что <span class="green">request.onsuccess</span>
                срабатывает несколько раз: по одному разу для каждого результата
            </p>
        </section>

        <section class="center">
            <h2>Что использовать, если хотим искать по условию?</h2>
            <p style="font-size: .8em">
                Например, нужно найти Заметки с именем Films?
            </p>
        </section>

        <section class="center">
            <h2 class="green">Использовать индексы</h2>
            <p style="font-size: .8em">
                Индекс – это “надстройка“ над хранилищем, отслеживающая заданное поле объекта.
            </p>
            <p style="font-size: .8em">
                Для каждого значения этого поля хранится список ключей для объектов, имеющих это значение.
            </p>
        </section>


        <section class="center">
            <h2>Пример индекса</h2>
            <img src="./images/index_example.png" />
        </section>

        <section>
            <h2>Создание индекса</h2>
            <pre class="flat">
                <code data-noescape data-trim>
                objectStore.createIndex(name, keyPath, [options]);

                // name – название индекса;
                // keyPath – путь к полю объекта,
                //     которое индекс должен отслеживать;
                // option – необязательный объект со свойствами:
                //     unique – если true, тогда в хранилище может быть только
                //          один объект с заданным значением в keyPath
                //     multiEntry – используется, если keyPath является
                //          массивом
                </code>
            </pre>
        </section>


        <section>
            <h2>Создание индекса (пример)</h2>
            <pre class="flat" style="margin-top: -75px;">
                <code data-noescape data-trim>
                openRequest.onupgradeneeded = function() {
                    let books = db.createObjectStore(
                        'books', { keyPath: 'id'}
                    );

                    // должны создать индекс в versionchange транзакции
                    let index = inventory.createIndex(
                        'price_idx', 'price'
                    );
                };

                // Храним книги с ключом id и хотим сделать поиск по price;
                // price неуникальное, опцию unique не устанавливаем,
                // price не является массивом, флаг multiEntry не применим
                </code>
            </pre>
        </section>


        <section>
            <h2>Использование индекса (пример)</h2>
            <pre class="flat" style="margin-top: -75px;">
                <code data-noescape data-trim>
                let transaction = db.transaction("books"); // readonly
                let books = transaction.objectStore("books");
                let priceIndex = books.index("price_idx");

                let request = priceIndex.getAll(10);

                request.onsuccess = function() {
                    if (request.result !== undefined) {
                        console.log("Книги", request.result); // цена книги 10
                    } else {
                        console.log("Нет таких книг");
                    }
                };
                </code>
            </pre>
        </section>


        <section>
            <h2>Поиск по диапазону (пример)</h2>
            <pre class="flat" style="margin-top: -75px;">
                <code data-noescape data-trim>
                let transaction = db.transaction("books"); // readonly
                let books = transaction.objectStore("books");
                let priceIndex = books.index("price_idx");

                let request = priceIndex.getAll(IDBKeyRange.upperBound(5));
                // IDBKeyRange – объекты, задающие «диапазон ключей»

                request.onsuccess = function() {
                    if (request.result !== undefined) {
                        console.log("Книги", request.result);
                        // цена книги < 5
                    } else {
                        console.log("Нет таких книг");
                    }
                };
                </code>
            </pre>
        </section>

        <section>
            <p><a href="http://dexie.org/">dexie.org</a></p>
            <pre class="flat"><code data-noescape data-trim>
        const db = new Dexie('MyDatabase');

        db
            .version(1)
            .stores({
                notes: 'name'
            });

        db
            .open()
            .catch(error => console.error(error));
            </code></pre>
        </section>

        <section>
            <p><a href="http://dexie.org/">dexie.org</a></p>
            <pre class="flat"><code data-noescape data-trim>
        db
            .notes
            .where('name')
            .equals(['films'])
            .each(note => {
                console.log(note.name);
            });
            </code></pre>
        </section>

        <section class="center">
            <p><a href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB">Using IndexedDB</a></p>
        </section>

        <section class="center">
            <h2>SPA</h2>
        </section>

        <section class="center">
            <h2>Приложение <span class="green">быстро загружается и работает</span></h2>
        </section>

        <section class="center">
            <p>Необходимые приложению статические <span class="green">ресурсы подгружаются один раз</span></p>
            <p><span class="green">Контент формируется динамически</span> без перезагрузки страницы</p>
        </section>

        <!-- <section class="center">
            <h2 class="green">Не требует написания серверной части</h2>
        </section> -->

        <section class="center">
            <h2>Приложение становится похожим на <span class="green">нативное</span></h2>
        </section>

        <section class="center">
            <h2 class="red">Тяжело делать SEO оптимизацию</h2>
        </section>

        <section class="center">
            <h2 >Изначально технология предоставляла возможность только менять содержимое страницы
                без её перезагрузки</h2>
        </section>

        <section class="center">
            <p style="font-size: 1em; text-align: left;">Разработчики научились
                загружать отдельные страницы с помощью JavaScript так, чтобы одновременно:</p>
            <p style="text-align: left;"><span class="green">- менялось содержание</span></p>
            <p style="text-align: left;"><span class="green">- генерировался новый адрес страницы</span></p>
        </section>

        <section class="center">
            <h2>History API</h2>
        </section>

        <section class="center">
            <p>
                History API опирается на один DOM интерфейс —
                <span class="green">объект History</span>.
                Он доступен через <span class="green">window.history</span>
            </p>
            <img src="images/history-api-1.png">
        </section>

        <section class="center">
            <h2 style="font-size: .9em">Основные методы и свойства объекта History</h2>
            <p style="font-size: .7em; text-align: left;">window.history.<span class="green">length</span></p>
            <p style="font-size: .7em; text-align: left;">window.history.<span class="green">state</span></p>
            <p style="font-size: .7em; text-align: left;">window.history.<span class="green">go(n)</span></p>
            <p style="font-size: .7em; text-align: left;">window.history.<span class="green">back()</span></p>
            <p style="font-size: .7em; text-align: left;">window.history.<span class="green">forward()</span></p>
            <p style="font-size: .7em; text-align: left;">window.history.<span class="green">pushState(data, title [, url])</span></p>
            <p style="font-size: .7em; text-align: left;">window.history.<span class="green">replaceState(data, title [, url])</span></p>
        </section>

        <section>
            <p style="font-size: .8em; text-align: left;">
                    window.history.<span class="green">length</span> –
                cвойство length хранит количество записей в текущей сессии истории
            </p>
            <pre class="javascript" style="height: 80px;">
                    <code data-noescape data-trim style="margin-top: -73px;">
                        window.history.length
                        // 10
                    </code>
            </pre>
            <img src="images/history-api-2.png">
        </section>

        <section class="center">
            <p style="font-size: .8em; text-align: left;">
                    window.history.<span class="green">state</span> –
                cвойство state хранит текущий объект истории
            </p>
            <pre class="javascript" style="height: 60px;">
                    <code data-noescape data-trim style="margin-top: -73px;">
                        window.history.state
                        // { history.id: 0 }
                    </code>
            </pre>
            <img src="images/history-api-3.png">
        </section>

        <section class="center">
            <p style="font-size: .8em; text-align: left;">
                    window.history.<span class="green">go(n)</span> –
                метод, загрузить конкретную страницу из истории сессии, определяемую относительной позицией к текущей странице
            </p>

            <p style="font-size: .8em; text-align: left;">
                Остаться на текущей странице –  window.history.<span class="green">go(0)</span>
            </p>
        </section>

        <section>
            <p style="font-size: .8em; text-align: left;">
                    window.history.<span class="green">back()</span> –
                метод, позволяющий перемещаться назад по истории
            </p>
            <img src="images/history-api-4.png">
            <pre class="javascript" style="height: 15px;">
                    <code data-noescape data-trim style="margin-top: -90px;">
                        window.history.back()
                    </code>
            </pre>
            <img src="images/history-api-5.png">
        </section>

        <section class="center">
            <p style="font-size: .8em; text-align: left;">
                    window.history.<span class="green">forward()</span> –
                метод, позволяющий перемещаться по истории. Идентичен вызову window.history.go(1)
            </p>
        </section>

        <section class="center">
            <p style="font-size: .8em; text-align: left;">
                    window.history.<span class="green">pushState(state, title [, url])</span> –
                метод, добавляющий новое состояние в историю браузера
            </p>
            <p style="font-size: .8em; text-align: left;">
                <span class="green">state</span> – любой валидный тип в JavaScript, который можно сериализовать
            </p>
            <p style="font-size: .8em; text-align: left;">
                <span class="green">title</span> – все современные браузеры игнорируют этот параметр
            </p>
            <p style="font-size: .8em; text-align: left;">
                <span class="green">url</span> – относительный/абсолютный URL новой записи в истории браузера
            </p>
        </section>

        <section class="center">
            <p style="font-size: .8em; text-align: left;">
                window.history.<span class="green">pushState(state, title [, url])</span> –
                метод, добавляющий новое состояние в историю браузера
            </p>
            <img src="images/history-api-9.png">
        </section>

        <section class="center">
            <img src="images/history-api-6.png" style="margin-top: 80px;">
            <pre class="javascript">
                <code data-noescape data-trim style="font-size:.4em;">
                    window.onpopstate = event => {
                        console.info("location: " + document.location + ", state: " +
                            JSON.stringify(event.state));
                    };
                    window.history.pushState({ page: 1 }, "title 1", "?page=1");
                    window.history.pushState({ page: 2 }, "title 2", "?page=2");
                    window.history.pushState({ page: 3 }, "title 3", "?page=3");
                    window.history.pushState({ page: 4 }, "title 4", "?page=4");
                </code>
            </pre>
        </section>

        <section class="center">
            <img src="images/history-api-7.png">
        </section>

        <section class="center">
            <pre class="javascript">
                <code data-noescape data-trim style="font-size:.6em; margin-top: -85px; margin-bottom: -125px;">
                    window.history.back();
                </code>
            </pre>
            <img src="images/history-api-8.png">
        </section>

        <section class="center">
            <p style="font-size: 0.8em; text-align: left;">
                    window.history.<span class="green">replaceState(state, title [, url])</span> –
                метод, обновляющий текущее состояние истории браузера
            </p>
            <img src="images/history-api-10.png">
        </section>

        <section class="center">
            <p>
                <span class="green">Cобытие popstate</span>
            </p>
            <p style="font-size: .8em; text-align: left;">
                <span class="red">Не вызывает событие</span>
            </p>
            <pre>
                <code style="margin-top: -120px; margin-bottom: -180px;">
                    window.history.pushState()
                    window.history.popState()
                </code>
            </pre>
            <p style="font-size: .8em; text-align: left;">
                <span class="green">Вызывает событие</span>
            </p>
            <pre>
                <code style="margin-top: -100px; margin-bottom: -180px;">
                    window.history.back()
                    window.history.forward()
                    Совершение действий в браузере
                    (нажатие стрелок для движения по истории)
                </code>
            </pre>
        </section>


        <section class="center">
            <pre class="javascript" style="margin-top: -60px;">
                <code data-noescape data-trim style="font-size:.5em; margin-top: -50px; margin-bottom: -125px;">
                    window.onpopstate = event => {
                        console.info("onpopstate-event", event);
                    };
                    window.history.pushState({ page: 1 }, "title1", "?page=1");
                    window.history.pushState({ page: 2 }, "title2", "?page=2");
                    window.history.replaceState({ page: 3 }, "title3", "?page=3");
                </code>
            </pre>
            <img src="images/history-api-13.png">
        </section>


        <section class="center">
            <pre class="javascript">
                <code data-noescape data-trim style="font-size:.6em; margin-top: -85px; margin-bottom: -125px;">
                    window.history.back();
                </code>
            </pre>
            <img src="images/history-api-14.png">
        </section>


        <!-- <section class="center">
            <pre class="javascript">
                <code data-noescape data-trim style="font-size:.5em; margin-top: -85px; margin-bottom: -125px;">
                    window.history.back();
                </code>
            </pre>
            <img src="images/history-api-11.png">
        </section> -->

        <section class="center" style="text-align: center;">
            Спасибо!
        </section>

        <script src="../../@lib/core.js"></script>
    </body>
</html>
